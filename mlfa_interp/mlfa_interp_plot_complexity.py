import matplotlib.pyplot as plt
import numpy
import os
from cycler import cycler
from examples.parameters import fig_width, fig_height


def mlfa_interp_read_complexity(filename):
    # Default file extension is .txt if none supplied
    if not os.path.splitext(filename)[1]:
        file = open(filename + ".txt", "r")
    else :
        file = open(filename, "r")

    epss = []
    accs = []
    mlfa_cost = []
    std_cost = []
    Ns = []
    ls = []

    for line in file :
        # Recognise file version line from the fact that it starts with '*** MLMC file version'
        if line[0 :21] == '*** MLFA file version' :
            file_version = float(line[23 :30])

        # Recognise MLFA complexity test lines from the fact that line[0] is an integer
        if '0' <= line[0] <= '9' :
            splitline = [float(x) for x in line.split() if set(x) != {"-"}]
            epss.append(splitline[0])
            accs.append(splitline[1])
            mlfa_cost.append(splitline[2])
            std_cost.append(splitline[3])
            Ns.append(splitline[5:])
            ls.append(list(range(0, len(splitline[5:]))))

    return epss, accs, mlfa_cost, std_cost, Ns, ls


def mlfa_interp_plot_complexity(filename, cost_exp=None, new_plot = True, save=False):
    """
    Utility to generate MLFA diagnostic plots based on
    input text file generated by MLFA driver code mlfa_test_complexity.
    cost_exp is a Fraction object, e.g. Fraction(3, 2) for eps^(3/2) cost.
    If new_plot = False, does not produce a new plot but rather adds to the current plot, on the third row.
    This is used in mlfa_interp_test_complexity.py to make one consistent plot.
    """
    #
    # Read in data
    #

    epss, accs, mlfa_cost, std_cost, Ns, ls = mlfa_interp_read_complexity(filename=filename)

    #
    # plot figures
    #

    if new_plot:
        nvert = 1
        plt.figure(figsize=(2 * fig_width, 1.5 * fig_height))
        plt.rc('font', size=16)
    else:
        nvert = 3

    # add marker styles to the below

    marker_styles = ['x', 'o', '^']
    line_styles = ['--', ':', '-.']
    plt.rc('axes', prop_cycle=(cycler('color', ['k']) *
                               (cycler('linestyle', line_styles) +
                                cycler('marker', marker_styles))))

    #
    # Plot number of samples per level
    #

    plt.subplot(nvert, 2, 2 * nvert - 1)
    for (eps, ll, n) in zip(epss, ls, Ns) :
        plt.semilogy(ll, n, label=eps, markerfacecolor='none')
    plt.xlabel('level $\ell$')
    plt.ylabel('$N_\ell$')
    plt.legend(loc='upper right', frameon=True, fontsize='medium')
    plt.gcf().text(-0.25, 1, '(e)', transform=plt.gca().transAxes, verticalalignment='top')

    #
    # Plot cost for given accuracy
    #

    plt.subplot(nvert, 2, 2 * nvert)
    std_cost = numpy.array(std_cost)
    mlfa_cost = numpy.array(mlfa_cost)
    acc = numpy.array(accs)
    if cost_exp is None:
        # relative cost
        std_cost = std_cost / mlfa_cost[0]
        mlfa_cost = mlfa_cost / mlfa_cost[0]
        plt.loglog(acc, std_cost, 'x-', label='$f^{\mathrm{SL}}$')
        plt.loglog(acc, mlfa_cost, 'x--', label='$f^{\mathrm{ML}}$')
        plt.ylabel("relative cost")
    else:
        plt.loglog(acc, acc ** cost_exp * std_cost, 'x-', label='$f^{\, \mathrm{SL}}$')
        plt.loglog(acc, acc ** cost_exp * mlfa_cost, 'x--', label='$f^{\, \mathrm{ML}}$')
        if cost_exp.denominator == 1 and cost_exp.numerator == 1:
            plt.ylabel(rf'$\varepsilon_{{\mathrm{{alg}}}} \mathrm{{cost}}(\cdot)$')
        elif cost_exp.denominator == 1:
            plt.ylabel(rf'$\varepsilon_{{\mathrm{{alg}}}}^{{{cost_exp.numerator}}} \mathrm{{cost}}(\cdot)$')
        else:
            plt.ylabel(rf'$\varepsilon_{{\mathrm{{alg}}}}^{{{cost_exp.numerator} / {cost_exp.denominator}}} \mathrm{{cost}}(\cdot)$')
    plt.xlabel(r'accuracy $\varepsilon_{\mathrm{alg}}$')
    plt.legend(fontsize='medium')
    plt.gcf().text(-0.25, 1, '(f)', transform=plt.gca().transAxes, verticalalignment='top')

    if new_plot:
        # fix subplot spacing
        plt.subplots_adjust(wspace=0.4)
        plt.subplots_adjust(hspace=0.4)
        if save :
            plt.savefig(filename.replace('.txt', '.eps'), format="eps", bbox_inches='tight')
        plt.show()
