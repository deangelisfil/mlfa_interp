import matplotlib.pyplot as plt
import numpy as np
import os
from cycler import cycler
from examples.parameters import fig_width, fig_height
from mlfa_interp.mlfa_interp_plot_complexity import mlfa_interp_plot_complexity
from numpy import log

def mlfa_interp_read_cvg(filename):
    """
    Reads the .txt file generated by the driver code mlfa_interp_test_cvg.
    """

    # Default file extension is .txt if none supplied
    if not os.path.splitext(filename)[1] :
        file = open(filename + ".txt", "r")
    else :
        file = open(filename, "r")

    # Declare lists for data
    max_yl = []
    max_errl = []
    interp_yl = []
    interp_errl = []
    interp_errn = []
    Nn_train = []
    cost = []
    l = []
    interp_error_flag = False
    # kur1 = []
    # chk1 = []

    for line in file :
        # Recognise file version line from the fact that it starts with '*** MLFA file version'
        if line[0 :21] == '*** MLFA file version' :
            file_version = float(line[23 :30])
        # Recognise number of samples line from the fact that it starts with '*** using l ='
        if line[0 :20] == '*** using level l = ' :
            interp_error_flag = True
            L0 = int(line[20 :22])
        # Recognise level line from the fact that it starts with '*** using N ='
        if line[0 :13] == '*** using N =' :
            # N = int(line[13:19])
            B = int(line[32 :36])
        if line[40 :43] == "I-I":
            how = "tensor"
        if line[40 :43] == "I-A" :
            how = "sparse"
        if line[0 :8] == '*** d = ':
            dim = int(line[8])
        # Recognise lines of convergence test w.r.t. levels from the fact that line[1] is an integer
        # and possibly also line[2] (or line[2] is whitespace) and interp_error_flag == False
        if line[0] == ' ' and ('0' <= line[1] <= '9') and not interp_error_flag:
            splitline = [float(x) for x in line.split() if set(x) != {"-"}]
            l.append(int(splitline[0]))
            max_yl.append(splitline[1])
            max_errl.append(splitline[2])
            interp_yl.append(splitline[3])
            interp_errl.append(splitline[4])
            cost.append(splitline[5])
        # Recognise lines of convergence test w.r.t. number of samples from the fact that line[0] is whitespace,
        # line[1] is digit and interp_error_flag == True
        if line[0] == ' ' and ('0' <= line[1] <= '9') and interp_error_flag :
            splitline = [float(x) for x in line.split() ]
            Nn_train.append(int(splitline[1]))
            interp_errn.append(splitline[2])
        # Recognise the convergence rate
        if line[0 :13] == ' alpha     = ' :
            alpha = float(line[13 :19])
        if line[0 :13] == ' beta      = ' :
            beta = float(line[13 :19])
        if line[0 :13] == ' gamma     = ' :
            gamma = float(line[13 :19])
        if line[0 :13] == ' delta     = ' :
            delta = float(line[13 :19])

    l = np.array(l)
    max_yl = np.array(max_yl)
    max_errl = np.array(max_errl)
    interp_yl = np.array(interp_yl)
    interp_errl = np.array(interp_errl)
    Nn_train = np.array(Nn_train)
    interp_errn = np.array(interp_errn)
    cost = np.array(cost)

    return how, dim, l, max_yl, max_errl, B, interp_yl, interp_errl, cost, L0, Nn_train, interp_errn, alpha, beta, gamma, delta

def mlfa_interp_plot_cvg(filename,
                         nvert,
                         gamma,
                         save=False,
                         filename_complexity=None,
                         cost_exp=None,
                         factor_N=1):
    """
    Utility to generate MLFA diagnostic plots based on
    input text file generated by MLFA driver code mlfa_interp_test_cvg.

    mlfa_interp_plot(filename, nvert, error_bars=False)

    Inputs:
        filename: string, (base of) filename with output from mlfa_interp_test_cvg routine
        nvert   : int, number of vertical plots <= 2
                    nvert == 1   generates fig1 and fig2 with (1)-(4)
                    nvert == 2   generates fig1 with (1)-(4)
                    nvert == 3   generates fig1 with (1)-(6)
        save    : determines where the generated figures are saved

    Outputs:
        Figures for convergence tests of MLFA interpolation
        (1) ||f_l|| and ||\Delta f_l|| per level l
        (2) ||(I-I_B)[f_l]|| and ||(I-I_B)[\Delta f_l]|| per level l
        (3) cost per level
        (4) ||(I-I_N)[f_L0]|| per number of samples N
        (5) number of samples per level
        (6) cost per accuracy
        # (5) kurtosis per level
    """
    if nvert == 3:
        assert filename_complexity is not None

    #
    # read in data
    #

    how, dim, l, max_yl, max_errl, B, interp_yl, interp_errl, cost, L0, Nn_train, interp_errn, _, _, _, _ = \
        mlfa_interp_read_cvg(filename)

    if how == "tensor":
        operator = "I"
    elif how == "sparse":
        operator = "A"
    else:
        raise NotImplementedError("filename is neither tensor nor sparse grid interpolation.")
    #
    # plot figures
    #

    if nvert == 3:
        plt.figure(figsize=(2 * fig_width, fig_height * (nvert + 1)))
    else:
        plt.figure(figsize=(2 * fig_width, fig_height * (nvert + 0.5)))

    plt.rc('axes', prop_cycle=(cycler('color', ['k']) *
                               cycler('linestyle', ['--']) *
                               cycler('marker', ['^', 'x'])))
    plt.rc('font', size=16)

    # plot Figure (1)
    plt.subplot(nvert, 2, 1)
    plt.semilogy(l, max_yl, label=r'$f_\ell$')
    plt.semilogy(l[1:], max_errl[1:], label=r'$\Delta f_\ell$')
    order_two = 2. ** (-2 * np.array(l))
    scale = 1 / order_two[-3] * 4 * max_errl[-3]
    plt.semilogy(l[-3:], scale * order_two[-3:], linestyle="dotted", marker='', color="k", label=r"$\alpha=2$")
    plt.xticks(l)
    plt.xlabel('level $\ell$')
    plt.ylabel(r'$\Vert \cdot \Vert_\infty$')
    plt.legend(loc='lower left')
    plt.gcf().text(-0.25, 1, '(a)', transform=plt.gca().transAxes, verticalalignment='top')

    # plot Figure (2)
    plt.subplot(nvert, 2, 2)
    plt.semilogy(l, interp_yl, label=r'$f_\ell$')
    plt.semilogy(l[1:], interp_errl[1:], label=r'$\Delta f_\ell$')
    scale = 1 / order_two[-3] * 4 * interp_errl[-3]
    plt.semilogy(l[-3:], scale * order_two[-3:], linestyle="dotted", marker='', color="k", label=r"$\beta=2$")
    plt.xticks(l)
    plt.ylabel(r'$\Vert (I - {}_{{{}}})[\cdot]\Vert_\infty$'.format(operator, B))
    plt.xlabel('level $\ell$')
    plt.legend(loc='lower left')
    plt.gcf().text(-0.25, 1, '(b)', transform=plt.gca().transAxes, verticalalignment='top')

    if nvert == 1:
        # Fix subplot spacing
        plt.subplots_adjust(wspace=0.4, hspace=0.4)
        if save:
            plt.savefig(filename.replace('.txt', '_fd_error.eps'), format="eps", bbox_inches='tight')
        plt.show()
        plt.figure(figsize=(fig_width * 2, fig_height * (nvert + 0.5)))

    # plot (3)
    rel_cost = cost / cost[0]
    plt.subplot(nvert, 2, 2 * min(nvert, 2) - 1)
    plt.semilogy(l, rel_cost, 'x--')
    order = 2. ** (gamma * np.array(l))
    scale = 1 / order[-3] * 4 * rel_cost[-3]
    plt.semilogy(l[-3:], scale * order[-3:], linestyle="dotted", marker='', color="k", label=r"$\gamma={}$".format(gamma))
    plt.xticks(l)
    plt.xlabel('level $\ell$')
    plt.ylabel(r'$C_\ell \, / \, C_0$')
    plt.legend()
    plt.gcf().text(-0.25, 1, '(c)', transform=plt.gca().transAxes, verticalalignment='top')

    # plot (4)
    plt.subplot(nvert, 2, 2 * min(nvert, 2))
    plt.loglog(Nn_train, interp_errn, 'x--')
    if how == "tensor":
        delta = 2 / dim
        delta_log = 0
        if nvert == 1:
            label = r"$\delta=2/{}$".format(dim)
        else:
            label = r"order $-2/{}$".format(dim)
        idx_start = -3
    else:
        # how == "sparse"
        delta = 2
        delta_log = 3 * (dim - 1)
        if factor_N == 1.:
            label = rf"$N^{{-2}} |log N|^{{{delta_log}}}$"
        else:
            label = rf"$({factor_N}N)^{{-2}} |log {factor_N}N|^{{{delta_log}}}$"
        idx_start = 0

    asy = (factor_N * Nn_train.astype(float)) ** (-delta) \
          * np.abs(log(factor_N * Nn_train)) ** delta_log
    scale = (factor_N * Nn_train[idx_start]) ** (delta) \
            * np.abs(log(factor_N * Nn_train[idx_start])) ** (-delta_log) \
            * 3 * interp_errn[idx_start]
    plt.loglog(Nn_train[idx_start:], scale * asy[idx_start:], linestyle="dotted", marker='', color="k", label=label)
    plt.xlabel(r'$N$')
    if L0 == 0:
        plt.ylabel(r'$\Vert (I - {}_N)[f_0] \Vert_\infty$'.format(operator))
    else:
        plt.ylabel(r'$\Vert (I - {}_N)[\Delta f_{{{}}}] \Vert_\infty$'.format(operator, L0))
    plt.legend(loc='lower left')
    plt.gcf().text(-0.25, 1, '(d)', transform=plt.gca().transAxes, verticalalignment='top')

    if nvert == 3:
        mlfa_interp_plot_complexity(filename_complexity, save=False, cost_exp=cost_exp, new_plot=False)

    # fix subplot spacing
    plt.subplots_adjust(wspace=0.4)
    plt.subplots_adjust(hspace=0.4)

    if save :
        plt.savefig(filename.replace('.txt', '.eps'), format="eps", bbox_inches='tight')
    plt.show()